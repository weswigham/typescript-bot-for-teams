// @ts-check
const path = require("path");
const fs = require("fs");
const crypto = require("crypto");
const prompts = require("prompts");
const msRestNodeAuth = require("@azure/ms-rest-nodeauth");
const { generateUuid } = require("@azure/ms-rest-js");
const { GraphRbacManagementClient } = require("@azure/graph");
const { ResourceManagementClient } = require("@azure/arm-resources");
const { SubscriptionClient } = require("@azure/arm-subscriptions");
const { StorageManagementClient } = require("@azure/arm-storage");
 
async function main() {
    // We need to prompt for the app name and deployment location
    const {
        appName,
        location,
    } = await prompts([{
        type: "text",
        name: "appName",
        message: "What do you want your app, bot, resource group, and service name to be (must be globally unique)?",
    }, {
        type: "text",
        name: "location",
        message: "What region do you want to host your bot in?",
        initial: "westus"
    }]);

    if (!appName) {
        console.error("You need an application name.");
        return process.exit(1);
    }

    console.log(`OK, I'm going to create your bot ${appName} in ${location}`);
    const authResp = await msRestNodeAuth.interactiveLoginWithAuthResponse();
    const subClient = new SubscriptionClient(authResp.credentials);
    const tennants = await subClient.tenants.list();
    const tennantId = tennants[0].tenantId;
    const reauth = await msRestNodeAuth.interactiveLoginWithAuthResponse({ domain: tennantId, tokenAudience: "https://graph.windows.net" });
    const client = new GraphRbacManagementClient(reauth.credentials, tennantId, { baseUri: "https://graph.windows.net/" });
    // equivalent to az ad app create --display-name \"appName\" --password \"<autogenerated>\" --available-to-other-tenants
    const autogeneratedPassword = crypto.randomBytes(128).toString("base64").replace(/[^A-Aa-z0-9]/g, "").slice(0, 62)+"&"; // max 64 characters, url encoded, include & at end to ensure a special char is present
    const app = await client.applications.create({
        availableToOtherTenants: true,
        displayName: appName,
        passwordCredentials: [{
           value: autogeneratedPassword,
           startDate: new Date(),
           endDate: new Date(Date.now() + 3.154e10),
           keyId: generateUuid(),
        }],

    });
    console.log(`Active directory app entry created, writing credentials to .env...`);

    // Write AppID and Password to the .env file
    await fs.promises.writeFile(path.join(__dirname, "..", ".env"), `MicrosoftAppId=${app.appId}
MicrosoftAppPassword=${autogeneratedPassword}`);

    console.log(`Starting template deployment...`);

    const reauthAgain = await msRestNodeAuth.interactiveLoginWithAuthResponse({ domain: tennantId });
    const resubClient = new SubscriptionClient(reauthAgain.credentials);
    const subs = await resubClient.subscriptions.list();
    const subscriptionId = subs[0].subscriptionId;
    // We need to cast the credentials here, since there's potentially a version mismatch between the two clients that
    // makes TS complain about mismatching private class members
    const armclient = new ResourceManagementClient(/** @type {*} */(reauthAgain.credentials), subscriptionId);
    // equivalent to az deployment create --name \"appName\" --template-file \"./deploymentTemplates/template-with-new-rg.json\" \
    //  --location \"location\" --parameters appId=\"app.appId\" appSecret=\"autogeneratedPassword\" botId=\"appName\" botSku=F0 \
    //  newAppServicePlanName=\"appName\" newWebAppName=\"appName\" groupName=\"appName\" \
    //  groupLocation=\"location\" newAppServicePlanLocation=\"location\"
    const template = await fs.promises.readFile(path.join(__dirname, "..", "deploymentTemplates", "template-with-new-rg.json"));
    await armclient.deployments.createOrUpdateAtSubscriptionScope(appName, {
        location,
        properties: {
            template: JSON.parse(template.toString()),
            mode: "Incremental",
            parameters: {
                appId: { value: app.appId },
                appSecret: { value: autogeneratedPassword },
                botId: { value: appName },
                botSku: { value: "F0" },
                newAppServicePlanName: {value: appName },
                newWebAppName: { value: appName },
                groupName: {value: appName },
                groupLocation: { value: location },
                newAppServicePlanLocation: { value: location }
            }
        }
    });
    console.log(`Deployed! Your bot has been provisioned!`);

    const service = new StorageManagementClient(/** @type {*} */(reauthAgain.credentials), subscriptionId);
    const storageAccountName = appName.replace(/\W/g, "").toLowerCase();
    const containerName = appName.toLowerCase();
    await service.storageAccounts.create(appName, storageAccountName, {
        location,
        kind: "BlobStorage",
        sku: {
            name: "Standard_LRS"
        },
        accessTier: "Hot"
    });
    await service.blobContainers.create(appName, storageAccountName, containerName, {
        publicAccess: "None",
    });
    const keyResp = await service.storageAccounts.regenerateKey(appName, storageAccountName, "key1");
    // Write AppID and Password to the .env file
    await fs.promises.writeFile(path.join(__dirname, "..", ".env"), `MicrosoftAppId=${app.appId}
MicrosoftAppPassword=${autogeneratedPassword}
StorageContainerName=${containerName}
StorageAccessKey=${keyResp.keys[0].value}
StorageAccount=${storageAccountName}`);
    console.log(`Blob storage provisioned and added to .env file!`);
}

main().catch(err => console.error(err));